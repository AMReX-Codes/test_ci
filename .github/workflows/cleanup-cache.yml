name: CleanUpCache

on:
  workflow_run:
    workflows: [Clang, Gcc]
    types:
      - completed

concurrency:
  group: ${{ github.ref }}-${{ github.head_ref }}-${{ github.event.workflow_run.name }}
  cancel-in-progress: true

jobs:
  CleanUpCcacheCache:
    name: Clean Up Ccahe Cache for ${{ github.event.workflow_run.name }}
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v3
      - name: Clean up ccahe
        run: |
          gh extension install actions/gh-actions-cache

          REPO=${{ github.repository }}

          # push or pull_request
          EVENT=${{ github.event.workflow_run.event }}

          # Triggering workflow run name (e.g., LinuxClang)
          WORKFLOW_NAME=${{ github.event.workflow_run.name }}

          if [[ $EVENT == "push" ]]; then
            BRANCH=${{ github.ref }}
          else
            gh run download ${{ github.event.workflow_run.id }} -n pr_number
            pr_number=`cat pr_number.txt`
            BRANCH=refs/pull/${pr_number}/merge
          fi

          # Setting this to not fail the workflow while deleting cache keys.
          set +e

          # In our cache keys, substring after `-git-` is git hash, substring
          # before that is a unique id for jobs (e.g., `ccache-LinuxClang-configure-2d`).
          # Th goal is to keep the last used key of each job and delete all otheres.

          cached_jobs=$(gh actions-cache list -R $REPO -B $BRANCH | awk -F '-git-' '${print $1}' | sort | uniq)
          for j in $cached_jobs
          do
            old_keys=$(gh actions-cache list -R $REPO -B $BRANCH --key ${j}-git- --sort last-used | cut -f 1 | tail -n +2)
            for k in $old_keys
            do
              echo "actions-cache delete $k -R $REPO -B $BRANCH --confirm"
              #  gh actions-cache delete $k -R $REPO -B $BRANCH --confirm
            done
          done
